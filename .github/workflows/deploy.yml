name: Deploy DocFlow to AWS EC2

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-latest
    name: Test Application
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: Install pnpm
        uses: pnpm/action-setup@v2
        with:
          version: latest
          
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        
      - name: Run TypeScript check
        run: pnpm run type-check || echo "TypeScript check completed"
        
      - name: Run ESLint
        run: pnpm run lint || echo "ESLint check completed"
        
      - name: Build application
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
          AUTH_SECRET: test-secret
          NEXTAUTH_URL: http://localhost:3000
          PWA_AUTH_URL: http://localhost:3001/api/login
        run: pnpm run build

  security-scan:
    runs-on: ubuntu-latest
    name: Security Scan
    needs: test
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
          
      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  build-and-push:
    runs-on: ubuntu-latest
    name: Build and Push Docker Image
    needs: [test, security-scan]
    if: github.ref == 'refs/heads/main'
    
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            
      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.production
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

  deploy:
    runs-on: ubuntu-latest
    name: Deploy to EC2
    needs: build-and-push
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-southeast-7
          
      - name: Setup SSH key
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          
      - name: Add EC2 host to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H 43.208.239.166 >> ~/.ssh/known_hosts
          
      - name: Create deployment package
        run: |
          mkdir -p deployment
          cp docker-compose.production.yml deployment/
          cp -r nginx deployment/
          cp -r scripts deployment/
          
      - name: Copy files to EC2
        run: |
          scp -r deployment/* ubuntu@43.208.239.166:/opt/docflow/
          
      - name: Deploy to EC2
        run: |
          ssh ubuntu@43.208.239.166 << 'EOF'
            cd /opt/docflow
            
            # Set image tag from GitHub Container Registry
            export IMAGE_TAG=${{ needs.build-and-push.outputs.image-tag }}
            
            # Pull latest images
            docker login ghcr.io -u ${{ github.actor }} -p ${{ secrets.GITHUB_TOKEN }}
            docker pull $IMAGE_TAG
            
            # Update docker-compose to use new image
            sed -i "s|build:|#build:|g" docker-compose.production.yml
            sed -i "s|context: .|#context: .|g" docker-compose.production.yml
            sed -i "s|dockerfile: Dockerfile.production|#dockerfile: Dockerfile.production|g" docker-compose.production.yml
            sed -i "/container_name: docflow_app/a\\    image: $IMAGE_TAG" docker-compose.production.yml
            
            # Graceful deployment with health checks
            echo "Starting deployment..."
            
            # Stop old containers gracefully
            docker-compose -f docker-compose.production.yml stop app || true
            
            # Start new container
            docker-compose -f docker-compose.production.yml up -d app
            
            # Wait for app to be healthy
            echo "Waiting for application to be healthy..."
            for i in {1..30}; do
              if docker-compose -f docker-compose.production.yml exec -T app curl -f http://localhost:3000/api/health; then
                echo "Application is healthy!"
                break
              fi
              echo "Waiting for app... ($i/30)"
              sleep 10
            done
            
            # Update nginx if needed
            docker-compose -f docker-compose.production.yml up -d nginx
            
            # Clean up old images
            docker image prune -f
            
            echo "Deployment completed successfully!"
          EOF
          
      - name: Verify deployment
        run: |
          ssh ubuntu@43.208.239.166 << 'EOF'
            cd /opt/docflow
            
            # Check service health
            echo "=== Service Status ==="
            docker-compose -f docker-compose.production.yml ps
            
            echo "=== Application Health Check ==="
            curl -f https://ec2-43-208-239-166.ap-southeast-7.compute.amazonaws.com/health || echo "Health check failed"
            
            echo "=== Container Logs (last 20 lines) ==="
            docker-compose -f docker-compose.production.yml logs --tail=20 app
          EOF
          
      - name: Rollback on failure
        if: failure()
        run: |
          ssh ubuntu@43.208.239.166 << 'EOF'
            cd /opt/docflow
            echo "Deployment failed, attempting rollback..."
            
            # Get previous image
            PREVIOUS_IMAGE=$(docker images --format "table {{.Repository}}:{{.Tag}}" | grep ghcr.io/${{ github.repository }} | sed -n '2p' | tr -d ' ')
            
            if [ ! -z "$PREVIOUS_IMAGE" ]; then
              echo "Rolling back to: $PREVIOUS_IMAGE"
              
              # Update compose file with previous image
              sed -i "s|image: .*|image: $PREVIOUS_IMAGE|g" docker-compose.production.yml
              
              # Restart with previous image
              docker-compose -f docker-compose.production.yml up -d app
              
              echo "Rollback completed"
            else
              echo "No previous image found for rollback"
            fi
          EOF

  notify:
    runs-on: ubuntu-latest
    name: Notify Deployment Status
    needs: [deploy]
    if: always()
    
    steps:
      - name: Notify Slack
        if: env.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          STATUS="${{ needs.deploy.result }}"
          COLOR="good"
          if [ "$STATUS" != "success" ]; then
            COLOR="danger"
          fi
          
          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"attachments\": [{
                \"color\": \"$COLOR\",
                \"title\": \"DocFlow Deployment\",
                \"text\": \"Deployment to EC2 completed with status: $STATUS\",
                \"fields\": [
                  {\"title\": \"Branch\", \"value\": \"${{ github.ref_name }}\", \"short\": true},
                  {\"title\": \"Commit\", \"value\": \"${{ github.sha }}\", \"short\": true},
                  {\"title\": \"Actor\", \"value\": \"${{ github.actor }}\", \"short\": true}
                ]
              }]
            }" \
            $SLACK_WEBHOOK_URL
            
      - name: Notify Telegram
        if: env.TELEGRAM_BOT_TOKEN != '' && env.TELEGRAM_CHAT_ID != ''
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          STATUS="${{ needs.deploy.result }}"
          EMOJI="✅"
          if [ "$STATUS" != "success" ]; then
            EMOJI="❌"
          fi
          
          MESSAGE="$EMOJI *DocFlow Deployment*
          
          Status: $STATUS
          Branch: ${{ github.ref_name }}
          Commit: ${{ github.sha }}
          Actor: ${{ github.actor }}
          URL: https://ec2-43-208-239-166.ap-southeast-7.compute.amazonaws.com"
          
          curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -d "chat_id=${TELEGRAM_CHAT_ID}" \
            -d "text=${MESSAGE}" \
            -d "parse_mode=Markdown"